<!-- TOC -->
- [1. 单线程、多线程](#1-单线程多线程)
- [2. 多路复用](#2-多路复用)
    - [2.1 linux select 源码简单分析](#21-linux-select-源码简单分析)
    - [2.2 select方法的缺点](#22-select方法的缺点)
    - [2.3 linux poll 函数](#23-linux-poll-函数)
    - [2.4 linux epoll 函数](#24-linux-epoll-函数)
    - [2.5 一句话概括select和epoll](#25-一句话概括select和epoll)
<!-- /TOC -->


## 1. 单线程、多线程

1. 多线程 => 上下文切换
2. 单线程 => 单线程不会存在上下文切换

## 2. 多路复用

比如一台服务器，已经在处理A请求，此时又进来了一个B请求，那么B请求会被丢失吗？答案是在处理IO，也就是去迎接B请求时，会有DMA去处理这个B请求，所以不会丢失。

在linux系统中一切都是文件，每个网络连接在linux中都是以文件描述符的形式存在，即：FD。

例如在服务器中有5个请求，A、B、C、D、E，那么我们写一个函数去处理这些请求：

```
// 去轮询io，这就是select的核心思想
while (1) {
    // fdxs即 [A,B,C,D,E]
    for (fdx ind fdxs) {
        if (fdx 是否有数据 ) {
            读fdx; 处理；
        }
    }
}
```

这个就是通过单线程去判断FD是否有数据，然后去处理。


### 2.1 linux select 源码简单分析

1. 程序准备阶段：（准备fd_set数组）

    首先创建fds，创建文件描述符。fd使用数组来实现。
    fd_size 是有限制的，即1024个bitmap(1024位)。 00110101010 0101010 ...

2. 程序运行阶段

    在select源码中，select方法传入了这个bitmap数组。
    
    select程序运行时，会将用户态中的bitmap数组拷贝到内核态中，然后内核来判断bitmap中哪个fd有数据。【内核态比用户态运行效率更高】

    如果select程序直接在用户态中对fd进行数据判断，但是用户态的判断最终还是要经过内核态来判断的。所以select方法直接将用户态的。

    如果fd一直没有数据，则在内核态中，整个select函数会阻塞住。select是一个阻塞函数。

    即如果fd没有数据，select函数就会被阻塞住。

3. 如果有数据来了
    ①  如果有数据来了，则会将bitmap中对应的fd进行置位，表示已经有数据了。（可能会置位多个fd）
    
    ②  会从阻塞的select函数返回；
    
    ③  然后读取有数据的那个fd，然后处理。


### 2.2 select方法的缺点

- fd数组（fd_set）只有1024bitmap
- (fd_set)bitmap不可重用
- 用户态到内核态有开销
- O(n)时间复杂度的轮询


### 2.3 linux poll 函数

1. 程序准备阶段：（准备pollfd结构体）

    相比于数组类型的fd_set，poll定义了一个结构体：poll_fd, 其中包含了 fd 和 events、revents。原理和select一样，都是在用户态中，poll函数将poll_fd拷贝到内核态，然后进行相应操作：判断     fd是否有数据，然后处理

2. 程序执行阶段

    ① 有数据进入的话，会将poll_fd结构中的revents进行置位为1，即pollin的状态，表示有数据进来，即设置为有数据，接着从poll方法返回；
    
    ② 然后poll返回后，判断当前poll_fd结构的revents是否为pollin状态，如果是的话就表示有数据进入，则进行”读数据“和处理数据操作。当然此时revents要置位为0。

    说明，所以revents置位为0之后，即可继续重用该pollfd结构了。

    因而，poll解决了select的缺点1和缺点2。

poll还有如下缺点：

    ① 用户态到内核态的切换存在开销；
    
    ② O(n)时间复杂度的轮询；



### 2.4 linux epoll 函数

1. epoll_create 程序准备阶段：（准备epoll_fd) 比喻成一个白板

    程序调用epoll_create创建一个eventpoll对象，也就是epoll_fd代表的对象。创建了的eventpoll会存放在fd列表中。

2. epoll_ctl 用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵红黑树上

    程序调用epoll_ctl来监听一个socket，也就是注册一个文件描述符fd，而注册了的文件描述符fd会被维护在一棵红黑树上，红黑树的搜索、插入和删除时间复杂度为O(logn)。

3. epoll_wait 通过回调函数内核会将 I/O 准备好的描述符加入到一个链表中管理，进程调用 epoll_wait() 便可以得到事件完成的描述符
    
    程序调用epoll_wait会监听已注册的文件描述符是否有事件返回，如果有则将有I/O准备好的描述符加入到一个链表中进行管理。

不需要轮询，时间复杂度为O(1)
解决select的1，2，3，4

因为epoll中，epoll_fd是将用户态和内核态都进行了共享的。

### 2.5 一句话概括select和epoll

- select

    类似于一堂考试，select的方式就是老师挨着询问（轮询）同学考卷是否已经完成。

- epoll

    类似于一堂考试，epoll的方式就是完成答卷的同学自己举手向老师示意，然后老师上前去收卷子。


> 文中有描述不当或者理解错误的地方，请大佬们指出
