## Java并发

### 1. LinkedBlockingQueue

1. 底层使用的是链表+ReentrantLock+Condition来实现的
2. 在LinkedBlockingQueue中包含了两个Condition对象，一个是notFull，另一个是notEmpty；如果LinkedBlockingQueue里对象是线程的话，notFull阻塞的是put操作的线程，如果是notEmpty的话，则阻塞的是take操作的线程；
3. 对于LinkedblockingQueue, put操作底层原理是先用可重入锁锁住，所以是线程安全的。锁住之后还用一个AtomicInteger类型的count来进行队列元素计数操作，如果put操作时判断count等于队列容量时，则notFull.await阻塞当前put操作的线程；如果其他其他线程从notFull中唤醒了此线程，并且此线程获得了CPU执行权后，则从notFull.await返回，执行入队操作，并且调用AtomicInteger的自增操作，并且释放掉可重入锁。接着判断AtomicInteger.getAndIncrement()结果的返回值c (方法开头设的初始值为-1)，如果成功则返回0，则表示队列中已经存入了一个新的元素(i++ 先获取i的值，然后自增)，可以唤醒notEmpty中等待的take线程。
4. 对于LinkedBlockingQueue，take操作也是使用的可重入锁来锁住核心逻辑，然后使用一个AtomicInteger来进行来进行计数（整个阻塞队列共用）。一个线层进来后先拿到可重入锁，然后判断count是否为0，为0的话则调用notEmpty.await()阻塞住当前线程；其他线程唤醒了notEmpty中阻塞的take线程后，并且获取到了CPU执行权后，则从notEmpty的await()方法返回，然后调用出队方法，随后调用count.getAndDecrement()方法，返回结果给c，随后在finally块中释放锁。最后再判断c==capacity，如果为true则表示已经有线程从队列中获取了元素，则去唤醒notFull阻塞队列中阻塞的线程，可以进行put操作了。
5. LinkedBlockignQueue常见操作有：add, put, take, offer, peek等

### 2. Lock接口

1. 锁是用来控制多个线程访问共享资源的一种方式，一般而言锁是放置多个线程同时访问共享资源（但是特殊的锁除外，如多写锁可以并发的访问共享资源）。
2. Lock接口的出现，是为了解决synchronize关键字实现的锁的缺陷，因为synchronize不能显示调用加锁和释放锁。Lock接口的出现，提供了锁获取、锁释放、可中断获取锁以及超时获取锁等多种synchronize不具备的特性。
3. 响应中断的意思是，例如一个线程获得了某个共享资源的执行权，即获得了锁，在执行到一半时被其他线程调用了interrupt方法，或者其他中断操作，导致当前线程被中断，会抛出一个InterruptedException异常来响应中断。
4. Lock接口的tryLock方法会去非阻塞获取锁，如果获取成功则返回true，否则返回false；tryLock方法还可以设置超时时间，而此时该方法调用线程有三种状态：① 超时时间内获取锁；② 超时，获取锁失败，返回false；③ 超时时间被中断，返回InterruptException；
5. Lock接口还定义了Condition.newCondition()方法，用于获取阻塞队列；当获线程获取了锁后，可以调用Condition对象的wait()方法阻塞自己，然后释放当前线程的锁。

### 3. AbstractQueuedSynchronizer（同步器)

AQS是JUC里的核心，是构建锁和其他同步组件的核心框架。

1. AQS里有一个int的成员变量表示同步状态：state，它是有volatile修饰的。
2. AQS里通过一个内置的同步队列来维持线程排队获取资源的工作，即获取state状态。
3. 其他同步器或者锁需要继承AQS来管理同步状态，因而实现自己的同步或者锁逻辑，而同步或者锁逻辑的实现则避免不了要修改同步状态，而AQS提供了setState()和getState()、compareAndSetState()来进行操作。
4. 同步器是实现锁的关键；同步器是面向锁开发者的；锁而是面向使用者的。开发则需要通过同步器实现锁的语义，而使用着则不关心锁底层逻辑。同步器就像锁匠，需要在底层实现锁的机制；使用者就想购买锁的用户，只要锁和解锁的功能。
5. AQS的核心功能一，独占式获取同步状态tryAquire(int args)。
6. AQS的核心功能二，独占式释放同步状态tryRelease(int args)。
7. AQS的核心功能三，共享式获取同步状态tryAcquireShared(int args)。
8. AQS的核心功能四，共享式释放同步状态tryReleaseShared(int args)。
9. AQS的同步队列通过管理内部的一个同步队列（FIFO的双向队列）来完成对同步状态的管理，该同步队列的实现逻辑为如下过程
    - ① 当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成一个节点（Node）并将其加入同步队列中（尾部），同时阻塞当前线程。
    - ② 当同步状态释放时，会把队列首节点中的线程唤醒，使其再次尝试获取同步状态。
    - ③ 同步状态中的节点内保存着的是获取同步状态失败的线程（被阻塞等待），等待状态，前驱结点和后继节点。
    - ④ 节点的等待状态waitStatus包含如下：CANCELLED（waitStatus值为1 ，由于同步队列中等待的线程因为等待超时或者是被中断，需要从同步队列中取消等待）；SIGNAL（waitStatus值为-1，后继节点的线程处于等待状态，而当前线程如果释放了同步状态或者是被取消了，将会通知后继节点，使后继节点的线程得以运行）。CONDITION（waitStatus值为-2，节点在阻塞队列中，节点线程阻塞在Condition阻塞队列中，当其他获取了锁的线程调用Condition.signal()方法后，该节点将会从阻塞队列中转移到同步队列中，加入到同步状态的获取中）；PROPAGATE（waitStatus值为-3，表示下一次共享同步状态的获取将会无条件地传播下去）；INITIAL（值为0，初始状态)
    - ⑤ 由于在获取锁时，是有多个线程一起竞争同步状态state的，但只能有一个线程能获取到同步状态，而其他线程则会获取失败，因而会被构造成同步队列的节点，一起被加入到同步队列的尾部，此时需要保证添加到同步队列尾部的线程安全性，因此AQS提供了一个compareAndSetTail()方法来实现。
    - ⑥ 同步队列首节点是获取同步状态成功的节点



