## Java并发

### 1. LinkedBlockingQueue

1. 底层使用的是链表+ReentrantLock+Condition来实现的
2. 在LinkedBlockingQueue中包含了两个Condition对象，一个是notFull，另一个是notEmpty；如果LinkedBlockingQueue里对象是线程的话，notFull阻塞的是put操作的线程，如果是notEmpty的话，则阻塞的是take操作的线程；
3. 对于LinkedblockingQueue, put操作底层原理是先用可重入锁锁住，所以是线程安全的。锁住之后还用一个AtomicInteger类型的count来进行队列元素计数操作，如果put操作时判断count等于队列容量时，则notFull.await阻塞当前put操作的线程；如果其他其他线程从notFull中唤醒了此线程，并且此线程获得了CPU执行权后，则从notFull.await返回，执行入队操作，并且调用AtomicInteger的自增操作，并且释放掉可重入锁。接着判断AtomicInteger.getAndIncrement()结果的返回值c (方法开头设的初始值为-1)，如果成功则返回0，则表示队列中已经存入了一个新的元素(i++ 先获取i的值，然后自增)，可以唤醒notEmpty中等待的take线程。
4. 对于LinkedBlockingQueue，take操作也是使用的可重入锁来锁住核心逻辑，然后使用一个AtomicInteger来进行来进行计数（整个阻塞队列共用）。一个线层进来后先拿到可重入锁，然后判断count是否为0，为0的话则调用notEmpty.await()阻塞住当前线程；其他线程唤醒了notEmpty中阻塞的take线程后，并且获取到了CPU执行权后，则从notEmpty的await()方法返回，然后调用出队方法，随后调用count.getAndDecrement()方法，返回结果给c，随后在finally块中释放锁。最后再判断c==capacity，如果为true则表示已经有线程从队列中获取了元素，则去唤醒notFull阻塞队列中阻塞的线程，可以进行put操作了。
5. LinkedBlockignQueue常见操作有：add, put, take, offer, peek等

### 2. SynchronousQueue

1. 底层使用的是堆栈和队列数据结构
2. SynchronousQueue不存储数据，其本身没有容量大小，即如果放入一个数据到SynchronousQueue中，方法调用是不能立即返回的，必须等到其他线程把数据消费调才能返回
3. 先进后出的堆栈和先进先出的队里都是有SynchronousQueue内部的一个Transfer内部类实现的，它们都共同调用了transfer方法
4. 如果没有特别指出，SynchronousQueue默认使用的是堆栈作为底层数据结构实现，因为堆栈的效率比队列的效率更高
5. 对于堆栈来说，其定义的SNode节点中有一个SNode match作为属性判断，如果SynchronousQueue中put了一个元素进来，则match会有值，此时take操作的线程就会判断到match中有数据，则可以执行take操作
6. SynchronousQueue的阻塞操作是有SNode中的Thread的线程阻塞方法来实现的
7. take和put这两个方法共用transfer，transfer中会判断是否有数据传进来，如果有则表示的是put操作，否则是take操作
8. SynchronousQueue底层阻塞实际用的是LockSupport.park操作，而更深的底层就是使用的是UNSAFE.park

### 3. DelayQueue

不同于阻塞队列，延迟队列指的是延迟一段时间后再执行队列操作。

1. DelayQueue是非常有意思的队列，底层使用了优先队列进行排序和超时阻塞实现了延迟队列
2. PriorityQueue使用的是堆排序（小根堆）
3. 超时阻塞使用的是锁的等待能力，这里的锁仍然是ReentrantLock可重入锁
4. PriorityQueue对于优先级的比较是通过delay值来进行比较的，delay值表示的是过期时间

### 4. ArraysBlockingQueue

按字面意思来说，ArraysBlockingQueue指的是数组阻塞队列

1. ArraysBlockingQueue是有界的阻塞队列，数组容量一旦被创建，后序则无法修改，这一点和普通的数组结构的类不一样，是不能进行动态扩容的
2. 队列中元素是有顺序的，先入先出进行排序，从队尾插入数据，从对头拿出数据
3. 队列满时，往队列中put数据会被阻塞；队列为空时，从队列中take数据会被阻塞
4. 队列中用的锁也是ReentrantLock，进行put和take操作时，就通过ReentrantLock来锁住
5. 对于put和take操作的阻塞，是由Condition来存储的；put阻塞于notFull的Condition中，take阻塞于notEmpty的Condition中。

### 5. Lock接口

1. 锁是用来控制多个线程访问共享资源的一种方式，一般而言锁是放置多个线程同时访问共享资源（但是特殊的锁除外，如多写锁可以并发的访问共享资源）。
2. Lock接口的出现，是为了解决synchronize关键字实现的锁的缺陷，因为synchronize不能显示调用加锁和释放锁。Lock接口的出现，提供了锁获取、锁释放、可中断获取锁以及超时获取锁等多种synchronize不具备的特性。
3. 响应中断的意思是，例如一个线程获得了某个共享资源的执行权，即获得了锁，在执行到一半时被其他线程调用了interrupt方法，或者其他中断操作，导致当前线程被中断，会抛出一个InterruptedException异常来响应中断。
4. Lock接口的tryLock方法会去非阻塞获取锁，如果获取成功则返回true，否则返回false；tryLock方法还可以设置超时时间，而此时该方法调用线程有三种状态：① 超时时间内获取锁；② 超时，获取锁失败，返回false；③ 超时时间被中断，返回InterruptException；
5. Lock接口还定义了Condition.newCondition()方法，用于获取阻塞队列；当获线程获取了锁后，可以调用Condition对象的wait()方法阻塞自己，然后释放当前线程的锁。

### 6. AbstractQueuedSynchronizer（同步器)

AQS是JUC里的核心，是构建锁和其他同步组件的核心框架。

1. AQS里有一个int的成员变量表示同步状态：state，它是有volatile修饰的。
2. AQS里通过一个内置的同步队列来维持线程排队获取资源的工作，即获取state状态。
3. 其他同步器或者锁需要继承AQS来管理同步状态，因而实现自己的同步或者锁逻辑，而同步或者锁逻辑的实现则避免不了要修改同步状态，而AQS提供了setState()和getState()、compareAndSetState()来进行操作。
4. 同步器是实现锁的关键；同步器是面向锁开发者的；锁而是面向使用者的。开发则需要通过同步器实现锁的语义，而使用着则不关心锁底层逻辑。同步器就像锁匠，需要在底层实现锁的机制；使用者就想购买锁的用户，只要锁和解锁的功能。
5. AQS的核心功能一，独占式获取同步状态tryAquire(int args)。
6. AQS的核心功能二，独占式释放同步状态tryRelease(int args)。
7. AQS的核心功能三，共享式获取同步状态tryAcquireShared(int args)。
8. AQS的核心功能四，共享式释放同步状态tryReleaseShared(int args)。
9. AQS的同步队列通过管理内部的一个同步队列（FIFO的双向队列）来完成对同步状态的管理，该同步队列的实现逻辑为如下过程
    - ① 当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成一个节点（Node）并将其加入同步队列中（尾部），同时阻塞当前线程。
    - ② 当同步状态释放时，会把队列首节点中的线程唤醒，使其再次尝试获取同步状态。
    - ③ 同步状态中的节点内保存着的是获取同步状态失败的线程（被阻塞等待），等待状态，前驱结点和后继节点。
    - ④ 节点的等待状态waitStatus包含如下：CANCELLED（waitStatus值为1 ，由于同步队列中等待的线程因为等待超时或者是被中断，需要从同步队列中取消等待）；SIGNAL（waitStatus值为-1，后继节点的线程处于等待状态，而当前线程如果释放了同步状态或者是被取消了，将会通知后继节点，使后继节点的线程得以运行）。CONDITION（waitStatus值为-2，节点在阻塞队列中，节点线程阻塞在Condition阻塞队列中，当其他获取了锁的线程调用Condition.signal()方法后，该节点将会从阻塞队列中转移到同步队列中，加入到同步状态的获取中）；PROPAGATE（waitStatus值为-3，表示下一次共享同步状态的获取将会无条件地传播下去）；INITIAL（值为0，初始状态)
    - ⑤ 由于在获取锁时，是有多个线程一起竞争同步状态state的，但只能有一个线程能获取到同步状态，而其他线程则会获取失败，因而会被构造成同步队列的节点，一起被加入到同步队列的尾部，此时需要保证添加到同步队列尾部的线程安全性，因此AQS提供了一个compareAndSetTail()方法来实现。
    - ⑥ 同步队列首节点是获取同步状态成功的节点

### 7. 线程池

### 8. 

### 9. 红黑树

详情请看博客[https://www.cnblogs.com/hello-shf/p/11364565.html](https://www.cnblogs.com/hello-shf/p/11364565.html)


1. 借助2-3树来理解红黑树。一棵2-3树是一颗绝对平衡的二叉树，2-3树有2节点的也有3节点类型的。对于2-3树的插入操作，需要通过融合、左旋或者右旋以及分裂来维护绝对平衡性。
2. 红黑树定义
    - 每个节点要么是红色，要么是黑色
    - 红黑树根节点是黑色的
    - 每个叶子节点（红黑树中叶子节点指的是最后一个没有子节点的节点）是黑色的
    - 如果一个节点是红色的，那么它的孩子都是黑色的
    - 从任意一个节点到叶子节点经过的黑色节点都是一样的










