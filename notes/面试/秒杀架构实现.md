## 1. 1核2G的服务器最大线程数应该设置为多少？

答，1核2G的服务器最大线程数应该在100左右；4核8G的服务器最大线程数在800左右（经过实际压测得出的结果）。

需要注意这里的最大线程树和"线程池的最大线程数不同"，对于IO密集型服务器，线程池最好开启2*CPU核数个线程（最大线程）；对于CPU密集型服务器，则线程池最好开启N*CPU核心个数（最大线程池）。

## 2. 对于秒杀场景，我们关心的是读（访问查询商品）和写（下单商品）这两不操作，

## 3. 在大型的应用集群中若对redis访问过度依赖，是否会产生应用服务对redis访问的带宽产生瓶颈，若产生瓶颈，如何解决这样的问题？

针对读请求导致的性能瓶颈，只需要在数据写入过程中复制一份，数据就变成两份，数据读能力就扩展了一倍。
写请求，redis是key-value存储结构，通过对写请求key做sharding，分散到不同的master实例上，解决写的瓶颈问题

## 4. redis系统中的热key和大key 该如何处理？

> 大key

大key会影响到服务的性能，比如value非常大的或者集合元素非常多的，那么如何发现呢？

在redis中，对于大可以，可以通过scan来扫描，

不过最新版本redis是有删除优化的功能，会自动删除大key。

> 热key

对于热key，可以通过：
1. 建立二级缓存；
2. 热key备份，然后分摊到多态redis中分摊压力；

## 5. 未优化前，交易性能瓶颈在哪？

和MySQL直接的IO过多，包括了查商品、查用户、下订单、减库存等等操作，会出现库存行锁问题。

问题就在于同步操作库存，会有库存行锁问题出现。所以需要引入异步化操作，即队列。对于扣减库存操作需要通过消息队列来实现
异步扣减。

在这个过程中，是先发送扣减库存的一个消息，然后再扣减redis缓存中的一个库存数量，而这都是需要保证事务一致性的。

## 6. 秒杀下单接口会被脚本不停的刷，该如何处理？秒杀下单和下单前的验证逻辑冗余了，该如何解决？

秒杀验证逻辑复杂，对交易系统产生无关联负载。

对此，需要一个秒杀令牌机制来限制下单接口被刷。

- 秒杀接口需要依靠令牌才能进入
- 秒杀的令牌由秒杀活动木块负责生成
- 秒杀活动模块对秒杀令牌生产全权负责
- 秒杀下单前需要先获得秒杀令牌

## 7. 什么是秒杀大闸原理？

- 依靠秒杀令牌的授权原理定制化发牌逻辑，做到大闸功能
- 根据秒杀商品初始库存办法对于数量令牌，控制大闸浏览
- 用户风控策略前置到秒杀令牌发放中
- 库存售罄判断前置到秒杀令牌发放中

## 8. 队列泄洪原理

- 排队有些时候比并发更加高效（例如redis单线程模型，innodb mutex key等）
- 依靠排队去限制并发流量
- 依靠排队和下游拥塞窗口程度调整队列释放流量
- 为了避免A端服务并发大，但是B端对接服务并发小的情况，对请求进行限制（保护下游服务）

不过需要注意的是，对于设置线程池为20最大线程数，表示的是最大并发请求为20，但不表示TPS为20。
并发和TPS是两个维度。

## 9. CompletableFuture

1. 底层实现了UNSAFE，调用了UNSAFE相关的CAS操作，除了get和join方法，都是无锁操作
2. CompletableFuture提升了开发人员的异步编程能力，方便开发异步编程代码
3. CompletableFuture底层大致的原理就是通过提供的线程池来运行指定任务，然后通过设置回调方法来获取线程执行结果，而main或者请求线程可以继续往下执行，
而不用像FutureTask这类api需要不断轮询判断任务是否已经执行完成了。














