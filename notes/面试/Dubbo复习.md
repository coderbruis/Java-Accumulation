## Dubbo SPI

### JDK的SPI定义以及使用分为四步
1. 定义一个接口及接口方法
2. 编写该接口的一个实现类
3. 在META-INF/services目录下，创建一个以接口全路径命名的文件
4. 文件内容为具体实现类的全路径名，如果有多个则以逗号分隔开
5. 在代码中通过java.util.ServiceLoader来加载扩展点具体的实现类

### Dubbo SPI使用的是策略模式，为的是”对扩展开放，对修改封闭“（开闭原则）；让接口和实现解耦，为Dubbo框架的扩展性奠定了基础

### JDK SPI的缺点
1. JDK SPI会一次性加载、实例化扩展点所有实现，并且扩展点实现的初始化会非常耗时，如果扩展点没有用到，则会非常浪费资源
2. 不支持IOC和AOP，即没有和Spring集成
3. 加载过程中如果报异常了，则会被吞掉，则无法进一步排查异常

### Dubbo SPI优化的地方
1. Dubbo SPI只是加载扩展点，并不会立即全部初始化，并且会根据扩展点类型的不同而缓存到内存中。、
2. Dubbo自己实现了IOC和AOP，让一个扩展可以通过setter直接注入到其他扩展点中
3. Dubbo SPI在扩展加载失败的时候会先抛出真实异常并打印日志

### Dubbo如何自己实现了IOC和AOP？

Dubbo通过支持包装扩展类，然后把通用功能的抽象逻辑放到包装类中，然后在核心逻辑的前后插入自己的逻辑进行代码增强，从而实现了扩展点的AOP功能。

而Dubb中，通过T injectExtension(T instanc)这个方法来实现的IOC功能。

### Dubbo中扩展点有哪些分类以及缓存
Dubbo的SPI可以分为两种缓存：
1. Class缓存
    
      Dubbo SPI获取扩展类时，会先从缓存中读取。如果缓存中不存在，则加
载配置文件，根据配置把Class缓存到内存中，并不会直接全部初始化。

2. 实例缓存

  基于性能考虑，Dubbo框架中不仅缓存Class,也会缓存Class实例化后的
对象。每次获取的时候，会先从缓存中读取，如果缓存中读不到，则重新加载并缓存
起来。这也是为什么Dubbo SPI相对Java SPI性能上有优势的原因，因为Dubbo SPI
缓存的Class并不会全部实例化，而是按需实例化并缓存，因此性能更好。


这两种缓存中又可以分为普通扩展类、包装扩展类（Wrapper类）、自适应扩展类（Adaptive类）

- 普通扩展类
    
    最基础的，配置在SPI配置文件中的扩展类实现。

- 包装扩展类

  这种Wrapper类没有具体的实现，只是做了通用逻辑的抽象，并且需要
在构造方法中传入一个具体的扩展接口的实现。属于Dubbo的自动包装特性。

- 自适应扩展类
  
  一个扩展接口会有多种实现类，具体使用哪个实现类可以不写死在配
置或代码中，在运行时，通过传入URL中的某些参数动态来确定。这属于扩展点的自适应特性。

### 扩展点的特性

从Dubbo官方文档中可以知道，扩展类一共包含四种特性：自动包装、自动加载、自适应
和自动激活。

### 扩展点注解

> @SPI

@SPI注解可以使用在类、接口和枚举类上，Dubbo框架中都是使用在接口上。它的主要作用就是标记这个接口是一个Dubbo SPI接口，即是一个扩展点，可以有多个不同的内置或用户
定义的实现。运行时需要通过配置找到具体的实现类。

Dubbo中很多地方通过getExtension (Class<T> type. String name)来获取扩展点接口的
具体实现，此时会对传入的Class做校验，判断是否是接口，以及是否有@SPI注解，两者缺一
不可。

> @Adaptive

@Adaptive注解可以标记在类、接口、枚举类和方法上，但是在整个Dubbo框架中，只有
几个地方使用在类级别上，如AdaptiveExtensionFactory和AdaptiveCompiler,其余都标注在
方法上。

如果标注在接口的方法上，即方法级别注解，则可以通过参数动态获得实现类，这一
点已经在自适应特性上说明。方法级别注解在第一次getExtension时，会自动生成
和编译一个动态的Adaptive类，从而达到动态实现类的效果。

 > @Activate
 
 @Activate可以标记在类、接口、枚举类和方法上。主要使用在有多个扩展点实现、需要根
据不同条件被激活的场景中，如Filter需要多个同时激活，因为每个Filter实现的是不同的功能。
©Activate可传入的参数很多。









